<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Classic Games Hub</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white">
  <div class="container mx-auto p-4">
    <h1 class="text-4xl font-bold text-center mb-8">Classic Games Hub</h1>
    <div id="game-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4 mb-8">
      <!-- Game tiles populated by JavaScript -->
    </div>
    <div id="game-container" class="flex justify-center">
      <div id="game-canvas" class="hidden border-4 border-gray-700 bg-black"></div>
      <div id="game-placeholder" class="text-center text-gray-400 text-xl">
        Select a game to start playing!
      </div>
    </div>
    <div id="game-instructions" class="text-center mt-4 text-gray-300"></div>
  </div>

  <script>
    // List of 25 classic games (5 implemented, 20 placeholders)
    const games = [
      { id: 'tetris', name: 'Tetris', implemented: true },
      { id: 'snake', name: 'Snake', implemented: true },
      { id: 'pong', name: 'Pong', implemented: true },
      { id: 'breakout', name: 'Breakout', implemented: true },
      { id: 'tictactoe', name: 'Tic-Tac-Toe', implemented: true },
      { id: 'pacman', name: 'Pac-Man', implemented: false },
      { id: 'space-invaders', name: 'Space Invaders', implemented: false },
      { id: 'asteroids', name: 'Asteroids', implemented: false },
      { id: 'galaga', name: 'Galaga', implemented: false },
      { id: 'frogger', name: 'Frogger', implemented: false },
      { id: 'centipede', name: 'Centipede', implemented: false },
      { id: 'minesweeper', name: 'Minesweeper', implemented: false },
      { id: 'connect4', name: 'Connect Four', implemented: false },
      { id: 'battleship', name: 'Battleship', implemented: false },
      { id: 'othello', name: 'Othello', implemented: false },
      { id: 'checkers', name: 'Checkers', implemented: false },
      { id: 'chess', name: 'Chess', implemented: false },
      { id: 'solitaire', name: 'Solitaire', implemented: false },
      { id: 'freecell', name: 'FreeCell', implemented: false },
      { id: 'arkanoid', name: 'Arkanoid', implemented: false },
      { id: 'digdug', name: 'Dig Dug', implemented: false },
      { id: 'qbert', name: 'Q*bert', implemented: false },
      { id: 'tetris-attack', name: 'Tetris Attack', implemented: false },
      { id: 'bubble-bobble', name: 'Bubble Bobble', implemented: false },
      { id: 'donkey-kong', name: 'Donkey Kong', implemented: false }
    ];

    // Game instructions
    const instructions = {
      tetris: 'Use LEFT/RIGHT to move, UP to rotate, DOWN to drop faster, SPACE to drop instantly.',
      snake: 'Use ARROW keys to move. Eat apples to grow, avoid walls and yourself.',
      pong: 'Use UP/DOWN to move left paddle. Player vs. AI, first to 5 wins.',
      breakout: 'Use LEFT/RIGHT to move paddle, bounce ball to break bricks.',
      tictactoe: 'Click a cell to place X. Play vs. AI (O). Get three in a row to win.',
      default: 'This game is not yet implemented. Select another game.'
    };

    // Populate game grid
    const gameGrid = document.getElementById('game-grid');
    games.forEach(game => {
      const tile = document.createElement('div');
      tile.className = 'bg-blue-600 text-white p-4 rounded-lg text-center cursor-pointer hover:bg-blue-700 transition';
      tile.textContent = game.name;
      tile.dataset.gameId = game.id;
      tile.addEventListener('click', () => loadGame(game.id));
      gameGrid.appendChild(tile);
    });

    let currentSketch = null;

    function loadGame(gameId) {
      const gameCanvas = document.getElementById('game-canvas');
      const gamePlaceholder = document.getElementById('game-placeholder');
      const gameInstructions = document.getElementById('game-instructions');
      gameCanvas.classList.remove('hidden');
      gamePlaceholder.classList.add('hidden');
      gameInstructions.textContent = instructions[gameId] || instructions.default;

      // Remove existing p5 instance
      if (currentSketch) {
        currentSketch.remove();
      }

      // Load game based on ID
      if (gameId === 'tetris') {
        currentSketch = new p5(sketchTetris, 'game-canvas');
      } else if (gameId === 'snake') {
        currentSketch = new p5(sketchSnake, 'game-canvas');
      } else if (gameId === 'pong') {
        currentSketch = new p5(sketchPong, 'game-canvas');
      } else if (gameId === 'breakout') {
        currentSketch = new p5(sketchBreakout, 'game-canvas');
      } else if (gameId === 'tictactoe') {
        currentSketch = new p5(sketchTicTacToe, 'game-canvas');
      } else {
        currentSketch = new p5(sketchPlaceholder, 'game-canvas');
      }
    }

    // Tetris Game
    const sketchTetris = (p) => {
      let grid = [];
      let currentPiece = null;
      let score = 0;
      let gameOver = false;
      const gridWidth = 10;
      const gridHeight = 20;
      const blockSize = 30;

      const shapes = [
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 0], [1, 1, 1]], // T
        [[1, 1, 0], [0, 1, 1]], // S
        [[0, 1, 1], [1, 1, 0]] // Z
      ];

      p.setup = () => {
        p.createCanvas(gridWidth * blockSize, gridHeight * blockSize);
        grid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(0));
        spawnPiece();
      };

      function spawnPiece() {
        const shapesIdx = Math.floor(Math.random() * shapes.length);
        currentPiece = {
          shape: shapes[shapesIdx],
          x: Math.floor(gridWidth / 2) - Math.floor(shapes[shapesIdx][0].length / 2),
          y: 0
        };
      }

      p.draw = () => {
        p.background(0);
        // Draw grid
        for (let y = 0; y < gridHeight; y++) {
          for (let x = 0; x < gridWidth; x++) {
            if (grid[y][x]) {
              p.fill(255);
              p.rect(x * blockSize, y * blockSize, blockSize, blockSize);
            }
          }
        }
        // Draw current piece
        if (currentPiece && !gameOver) {
          p.fill(255, 0, 0);
          for (let y = 0; y < currentPiece.shape.length; y++) {
            for (let x = 0; x < currentPiece.shape[y].length; x++) {
              if (currentPiece.shape[y][x]) {
                p.rect((currentPiece.x + x) * blockSize, (currentPiece.y + y) * blockSize, blockSize, blockSize);
              }
            }
          }
          // Move piece down
          if (p.frameCount % 30 === 0) {
            movePieceDown();
          }
        }
        // Draw score
        p.fill(255);
        p.textSize(20);
        p.text(`Score: ${score}`, 10, 30);
        if (gameOver) {
          p.textSize(40);
          p.textAlign(p.CENTER);
          p.text('Game Over', p.width / 2, p.height / 2);
        }
      };

      function movePieceDown() {
        if (canMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
          currentPiece.y++;
        } else {
          placePiece();
          clearLines();
          spawnPiece();
          if (!canMove(currentPiece.shape, currentPiece.x, currentPiece.y)) {
            gameOver = true;
          }
        }
      }

      function canMove(shape, x, y) {
        for (let sy = 0; sy < shape.length; sy++) {
          for (let sx = 0; sx < shape[sy].length; sx++) {
            if (shape[sy][sx]) {
              const newX = x + sx;
              const newY = y + sy;
              if (newX < 0 || newX >= gridWidth || newY >= gridHeight || (newY >= 0 && grid[newY][newX])) {
                return false;
              }
            }
          }
        }
        return true;
      }

      function placePiece() {
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              grid[currentPiece.y + y][currentPiece.x + x] = 1;
            }
          }
        }
      }

      function clearLines() {
        let linesCleared = 0;
        for (let y = gridHeight - 1; y >= 0; y--) {
          if (grid[y].every(cell => cell)) {
            grid.splice(y, 1);
            grid.unshift(Array(gridWidth).fill(0));
            linesCleared++;
            y++;
          }
        }
        score += linesCleared * 100;
      }

      function rotatePiece() {
        const newShape = Array(currentPiece.shape[0].length).fill().map(() => Array(currentPiece.shape.length).fill(0));
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            newShape[x][currentPiece.shape.length - 1 - y] = currentPiece.shape[y][x];
          }
        }
        if (canMove(newShape, currentPiece.x, currentPiece.y)) {
          currentPiece.shape = newShape;
        }
      }

      p.keyPressed = () => {
        if (!gameOver) {
          if (p.keyCode === p.LEFT_ARROW && canMove(currentPiece.shape, currentPiece.x - 1, currentPiece.y)) {
            currentPiece.x--;
          } else if (p.keyCode === p.RIGHT_ARROW && canMove(currentPiece.shape, currentPiece.x + 1, currentPiece.y)) {
            currentPiece.x++;
          } else if (p.keyCode === p.DOWN_ARROW) {
            movePieceDown();
          } else if (p.keyCode === p.UP_ARROW) {
            rotatePiece();
          } else if (p.keyCode === 32) { // Spacebar
            while (canMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
              currentPiece.y++;
            }
            movePieceDown();
          }
        }
      };
    };

    // Snake Game
    const sketchSnake = (p) => {
      let snake = [{ x: 10, y: 10 }];
      let food = { x: 15, y: 15 };
      let dir = { x: 1, y: 0 };
      let gridSize = 20;
      let tileSize = 20;
      let score = 0;
      let gameOver = false;

      p.setup = () => {
        p.createCanvas(gridSize * tileSize, gridSize * tileSize);
        p.frameRate(10);
        spawnFood();
      };

      function spawnFood() {
        food = {
          x: Math.floor(Math.random() * gridSize),
          y: Math.floor(Math.random() * gridSize)
        };
      }

      p.draw = () => {
        p.background(0);
        if (!gameOver) {
          // Update snake
          let head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
          if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize || snake.some(s => s.x === head.x && s.y === head.y)) {
            gameOver = true;
          } else {
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
              score += 10;
              spawnFood();
            } else {
              snake.pop();
            }
          }
        }
        // Draw snake
        p.fill(0, 255, 0);
        snake.forEach(segment => {
          p.rect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
        });
        // Draw food
        p.fill(255, 0, 0);
        p.rect(food.x * tileSize, food.y * tileSize, tileSize, tileSize);
        // Draw score
        p.fill(255);
        p.textSize(20);
        p.text(`Score: ${score}`, 10, 30);
        if (gameOver) {
          p.textSize(40);
          p.textAlign(p.CENTER);
          p.text('Game Over', p.width / 2, p.height / 2);
        }
      };

      p.keyPressed = () => {
        if (!gameOver) {
          if (p.keyCode === p.UP_ARROW && dir.y === 0) {
            dir = { x: 0, y: -1 };
          } else if (p.keyCode === p.DOWN_ARROW && dir.y === 0) {
            dir = { x: 0, y: 1 };
          } else if (p.keyCode === p.LEFT_ARROW && dir.x === 0) {
            dir = { x: -1, y: 0 };
          } else if (p.keyCode === p.RIGHT_ARROW && dir.x === 0) {
            dir = { x: 1, y: 0 };
          }
        }
      };
    };

    // Pong Game
    const sketchPong = (p) => {
      let ball = { x: 200, y: 200, dx: 4, dy: 4 };
      let paddleLeft = { y: 150, h: 100, w: 10 };
      let paddleRight = { y: 150, h: 100, w: 10 };
      let scoreLeft = 0;
      let scoreRight = 0;
      let gameOver = false;

      p.setup = () => {
        p.createCanvas(400, 400);
      };

      p.draw = () => {
        p.background(0);
        if (!gameOver) {
          // Move ball
          ball.x += ball.dx;
          ball.y += ball.dy;
          // Bounce off top/bottom
          if (ball.y < 0 || ball.y > p.height) {
            ball.dy *= -1;
          }
          // Bounce off paddles
          if (ball.x < 20 && ball.y > paddleLeft.y && ball.y < paddleLeft.y + paddleLeft.h) {
            ball.dx *= -1;
          } else if (ball.x > p.width - 20 && ball.y > paddleRight.y && ball.y < paddleRight.y + paddleRight.h) {
            ball.dx *= -1;
          }
          // Score points
          if (ball.x < 0) {
            scoreRight++;
            resetBall();
          } else if (ball.x > p.width) {
            scoreLeft++;
            resetBall();
          }
          // AI for right paddle
          paddleRight.y = ball.y - paddleRight.h / 2;
          paddleRight.y = p.constrain(paddleRight.y, 0, p.height - paddleRight.h);
          // Check game over
          if (scoreLeft >= 5 || scoreRight >= 5) {
            gameOver = true;
          }
        }
        // Draw paddles
        p.fill(255);
        p.rect(10, paddleLeft.y, paddleLeft.w, paddleLeft.h);
        p.rect(p.width - 20, paddleRight.y, paddleRight.w, paddleRight.h);
        // Draw ball
        p.ellipse(ball.x, ball.y, 10, 10);
        // Draw scores
        p.textSize(20);
        p.textAlign(p.LEFT);
        p.text(scoreLeft, 50, 30);
        p.textAlign(p.RIGHT);
        p.text(scoreRight, p.width - 50, 30);
        if (gameOver) {
          p.textSize(40);
          p.textAlign(p.CENTER);
          p.text('Game Over', p.width / 2, p.height / 2);
        }
      };

      function resetBall() {
        ball.x = p.width / 2;
        ball.y = p.height / 2;
        ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
        ball.dy = 4 * (Math.random() > 0.5 ? 1 : -1);
      }

      p.keyPressed = () => {
        if (!gameOver) {
          if (p.keyCode === p.UP_ARROW) {
            paddleLeft.y -= 20;
          } else if (p.keyCode === p.DOWN_ARROW) {
            paddleLeft.y += 20;
          }
          paddleLeft.y = p.constrain(paddleLeft.y, 0, p.height - paddleLeft.h);
        }
      };
    };

    // Breakout Game
    const sketchBreakout = (p) => {
      let paddle = { x: 200, y: 380, w: 80, h: 10 };
      let ball = { x: 200, y: 200, dx: 4, dy: -4, r: 5 };
      let bricks = [];
      let score = 0;
      let gameOver = false;

      p.setup = () => {
        p.createCanvas(400, 400);
        for (let i = 0; i < 5; i++) {
          for (let j = 0; j < 8; j++) {
            bricks.push({ x: j * 50 + 10, y: i * 20 + 30, w: 40, h: 10 });
          }
        }
      };

      p.draw = () => {
        p.background(0);
        if (!gameOver) {
          // Move ball
          ball.x += ball.dx;
          ball.y += ball.dy;
          // Bounce off walls
          if (ball.x < ball.r || ball.x > p.width - ball.r) {
            ball.dx *= -1;
          }
          if (ball.y < ball.r) {
            ball.dy *= -1;
          }
          // Bounce off paddle
          if (ball.y > paddle.y - ball.r && ball.x > paddle.x && ball.x < paddle.x + paddle.w) {
            ball.dy *= -1;
          }
          // Check brick collisions
          bricks = bricks.filter(brick => {
            if (ball.x > brick.x && ball.x < brick.x + brick.w && ball.y > brick.y && ball.y < brick.y + brick.h) {
              ball.dy *= -1;
              score += 10;
              return false;
            }
            return true;
          });
          // Check game over
          if (ball.y > p.height) {
            gameOver = true;
          }
          if (bricks.length === 0) {
            gameOver = true;
          }
        }
        // Draw paddle
        p.fill(255);
        p.rect(paddle.x, paddle.y, paddle.w, paddle.h);
        // Draw ball
        p.ellipse(ball.x, ball.y, ball.r * 2);
        // Draw bricks
        bricks.forEach(brick => {
          p.rect(brick.x, brick.y, brick.w, brick.h);
        });
        // Draw score
        p.textSize(20);
        p.text(`Score: ${score}`, 10, 20);
        if (gameOver) {
          p.textSize(40);
          p.textAlign(p.CENTER);
          p.text(bricks.length === 0 ? 'You Win!' : 'Game Over', p.width / 2, p.height / 2);
        }
      };

      p.keyPressed = () => {
        if (!gameOver) {
          if (p.keyCode === p.LEFT_ARROW) {
            paddle.x -= 20;
          } else if (p.keyCode === p.RIGHT_ARROW) {
            paddle.x += 20;
          }
          paddle.x = p.constrain(paddle.x, 0, p.width - paddle.w);
        }
      };
    };

    // Tic-Tac-Toe Game
    const sketchTicTacToe = (p) => {
      let board = Array(3).fill().map(() => Array(3).fill(''));
      let currentPlayer = 'X';
      let gameOver = false;
      let winner = null;
      let cellSize = 100;

      p.setup = () => {
        p.createCanvas(300, 300);
      };

      p.draw = () => {
        p.background(0);
        // Draw grid
        p.stroke(255);
        p.strokeWeight(4);
        p.line(100, 0, 100, 300);
        p.line(200, 0, 200, 300);
        p.line(0, 100, 300, 100);
        p.line(0, 200, 300, 200);
        // Draw pieces
        p.textSize(60);
        p.textAlign(p.CENTER, p.CENTER);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (board[i][j]) {
              p.fill(board[i][j] === 'X' ? 'red' : 'blue');
              p.text(board[i][j], j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
            }
          }
        }
        if (gameOver) {
          p.fill(255);
          p.textSize(40);
          p.textAlign(p.CENTER);
          p.text(winner ? `${winner} Wins!` : 'Draw!', p.width / 2, p.height / 2);
        }
      };

      p.mousePressed = () => {
        if (!gameOver && currentPlayer === 'X') {
          let i = Math.floor(p.mouseY / cellSize);
          let j = Math.floor(p.mouseX / cellSize);
          if (i >= 0 && i < 3 && j >= 0 && j < 3 && board[i][j] === '') {
            board[i][j] = 'X';
            checkGameState();
            if (!gameOver) {
              aiMove();
              checkGameState();
            }
          }
        }
      };

      function aiMove() {
        let emptyCells = [];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (board[i][j] === '') {
              emptyCells.push({ i, j });
            }
          }
        }
        if (emptyCells.length > 0) {
          let move = emptyCells[Math.floor(Math.random() * emptyCells.length)];
          board[move.i][move.j] = 'O';
        }
      }

      function checkGameState() {
        // Check rows, columns, diagonals
        for (let i = 0; i < 3; i++) {
          if (board[i][0] && board[i][0] === board[i][1] && board[i][1] === board[i][2]) {
            winner = board[i][0];
            gameOver = true;
            return;
          }
          if (board[0][i] && board[0][i] === board[1][i] && board[1][i] === board[2][i]) {
            winner = board[0][i];
            gameOver = true;
            return;
          }
        }
        if (board[0][0] && board[0][0] === board[1][1] && board[1][1] === board[2][2]) {
          winner = board[0][0];
          gameOver = true;
          return;
        }
        if (board[0][2] && board[0][2] === board[1][1] && board[1][1] === board[2][0]) {
          winner = board[0][2];
          gameOver = true;
          return;
        }
        // Check for draw
        if (board.every(row => row.every(cell => cell !== ''))) {
          gameOver = true;
        }
      }
    };

    // Placeholder for unimplemented games
    const sketchPlaceholder = (p) => {
      p.setup = () => {
        p.createCanvas(400, 400);
      };
      p.draw = () => {
        p.background(0);
        p.fill(255);
        p.textSize(20);
        p.textAlign(p.CENTER);
        p.text('Game not yet implemented', p.width / 2, p.height / 2);
      };
    };
  </script>
</body>
</html>
